---
title: Installation and setup
description: Mise en place d'un environnement de développement
synopsis: 
  We will start by setting up a development environment 
  for using YOCaml in a project. This setup is very similar 
  to what is usually done in OCaml.

date: 2025-08-29
updates:
  - key: 2025-08-29
    value:
      description: "First version"
      authors: ["grm <grimfw@gmail.com>", "xvw <xaviervdw@gmail.com>"]
---

Creating a YOCaml project (_a site generated by YOCaml_) requires a
ready-to-use OCaml development environment. In this guide, we will see
how to set up a reproducible base for using YOCaml. Before starting,
make sure that OCaml is installed, in particular by checking that
[OPAM](https://opam.ocaml.org) is available in your `$PATH`. (You can
refer to the [instructions](https://ocaml.org/install#linux_mac_bsd)
on the official site).

### Aside on switches

A common approach is to _sandbox_ your project using
[_switches_](https://ocaml.org/docs/opam-switch-introduction) so as
not to share dependencies with your other projects. For this guide, we
will assume that you are using a _switch_ dedicated to the
tutorial. However, if you are already familiar with OCaml and OPAM,
you are, of course, free to organize your dependencies as you see fit.


#### Create an empty switch for the project

Even though YOCaml is released for all OCaml versions `>= 5.1.0`, we
use version `5.3.x` for the tutorials. You can run the following
commands in a _shell_ from the directory where you want to create your
project:


```shell
mkdir my-first-blog
cd my-first-blog
opam update
opam switch create . 5.3.0 -y
eval $(opam env)
opam install dune
```

We start by creating (`mkdir`) the directory where we will develop our
project, then move into it (`cd`). We update the OPAM package
repositories with `opam update`. We initialize a _switch_ for version
`5.3.0` of OCaml (the `-y` flag validates all steps
automatically). Running `opam env` sets up the necessary environment
variables for using the OCaml _toolchain_ (associated with the
_switch_ we just created). Finally, we install
[Dune](https://dune.build/), the recommended _package manager_.

Once these commands are executed, the `my-first-blog` directory will
be associated with a _switch_, in which all our dependencies will be
installed (_sandboxed_).


### Project setup

Now that our _switch_ is set up, we can actually put the project in
place. There are several approaches to _initialize_ an OCaml project
(for example, by running a series of commands), but the approach we
recommend here has the advantage of making the project easily
_cloneable_ and will simplify setting up _continuous integration_ (to,
for instance, automate the deployment of new versions of your site).

Although it is possible to initialize a project using Dune’s _CLI_
(`dune init`), we will create the files manually in order to better
understand the different aspects of the setup and to have fine-grained
control over how the project is organized. However, if you are already
familiar with the OCaml ecosystem, you can stick to your usual
workflow. Since **YOCaml is just a collection of regular OCaml
packages, no special ceremony is required**.


#### Project description

The project is described in Dune through the `dune-project` file. This
is a file where we describe a project's metadata and dependencies
(organized by packages) using
[S-expressions](https://en.wikipedia.org/wiki/S-expression). At the
root of `my-first-blog`, let's create the `dune-project` file:


```shell
touch dune-project
dune --version
```

The second line lets us see which version of Dune is installed in our
_switch_, which will allow us to choose the version of the _Dune
language_ we will use for our project.


> The _Dune language_ is a fantastic tool that allows you to describe
> the features offered by Dune while ensuring a form of backward
> compatibility. As new versions of Dune are released, the tool
> remains compatible with previous versions of the language, allowing
> a modern version of Dune to run projects configured for an earlier
> version. If you are using version `x.y.z`, you should specify the
> version as `(lang dune x.y)`.

Now that we know our Dune version, we can fill in the `dune-project`
file:


```dune
(lang dune 3.20)
(name blog)
(version dev)
(generate_opam_files)
(executables_implicit_empty_intf)

(source (github username/blog))
(license MIT)
(authors "your name <you@domain.com>")
(maintainers "your name <you@domain.com>")

(package
 (name blog)
 (synopsis "My first blog using YOCaml")
 (description 
   "My first personal blog using YOCaml for 
   fun and profit")
 (depends
  (ocaml (>= 5.3.0))))
```

The first part of the file outlines how Dune will handle the project —
essentially configuring the entire project. The two fields that can be
a bit confusing are:

- `(generate_opam_files)`: This instructs Dune to create the OPAM
  description files. Dune is just the _build system_, and OPAM is the
  package manager. This field tells Dune to regenerate the OPAM files,
  centralizing the project configuration in our `dune-project`.

- `(executables_implicit_empty_intf)`: This automatically creates an
  empty interface file for executables, allowing the compiler to
  _track_ unused definitions. In practice, this is recommended, but
  optional.

The second part of the file specifies additional metadata. The
_repository_ (here we used [GitHub](https://github.com) as the host)
allows generating additional fields (like a link to the _bug
tracker_). It also lists the project _maintainers_ and _authors_, and
the license under which the project is distributed. Here, it is `MIT`,
but a [wide variety of license
identifiers](https://spdx.dev/use/overview/) are supported.

The final part concretely describes our package: its name,
dependencies, etc. In our case, for now, we only depend on OCaml, with
the Dune dependency inferred from the `(lang dune ...)` field.


#### Development environment

If you started from a _switch_ dedicated to the project, the
_sandboxing_ means there is no pre-configured development
environment. The OCaml website provides an excellent [introduction to
setting up a development
environment](https://ocaml.org/docs/set-up-editor) that details the
steps to configure your editor. To centralize dependencies (including
development ones), we can edit the `package` section of `dune-project`
to include our development dependencies:


```diff
  (package
   (name blog)
   (synopsis "My first blog using YOCaml")
   (description 
     "My first personal blog using YOCaml for 
     fun and profit")
   (depends
-   (ocaml (>= 5.3.0))))
+   (ocaml (>= 5.3.0))
+
+  ;; Dev setup
+  (utop :with-dev-setup)
+  (ocamlformat :with-dev-setup)
+  (ocp-indent :with-dev-setup)
+  (merlin :with-dev-setup)
+  (ocaml-lsp-server :with-dev-setup)))
```

From our point of view, this set of packages is sufficient to provide
a pleasant OCaml development experience, even if, in this tutorial, we
may not use all of them:

- [Utop](https://ocaml.org/p/utop/latest) is a
  [REPL](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop)
  that integrates very well with Dune. Running `dune utop` at the root
  of your project will start an interactive loop with your project and
  its available dependencies.

- [ocamlformat](https://ocaml.org/p/ocamlformat/latest) is an OCaml
  code formatter that formats code according to a configurable style.

- [OCP-indent](https://ocaml.org/p/ocp-indent/latest) is an efficient
  tool that, among other things, calculates the cursor position after
  a line break by applying OCaml-specific indentation rules.

- [Merlin](https://ocaml.org/p/merlin/latest) is a server providing
  IDE services (notably for Emacs and Vim).

- [OCaml-lsp-server](https://ocaml.org/p/ocaml-lsp-server/latest) is
  another server that provides IDE services based on
  [LSP](https://microsoft.github.io/language-server-protocol/),
  allowing any editor with an LSP client to offer a pleasant OCaml
  editing experience.

If your editor is properly configured, our `my-first-blog` directory
should be associated with a _switch_ that has all the ingredients to
start using YOCaml!

> Having both Merlin and OCaml-lsp-server may seem redundant, but from
> our point of view, it allows the development environment (associated
> with the `with-dev-setup` context) to be compatible with many
> workflows, enabling both Merlin and LSP users to have a functional
> setup. Additionally, since OCaml-lsp-server depends on Merlin, the
> dependencies are shared, and adding Merlin comes at a relatively low
> cost.


##### Code formatting

Installing Ocamlformat in a _switch_ is not enough to enable
formatting; the tool must be configured. Adding a `.ocamlformat` file
at the root of the project (in the `my-first-blog` directory) is
sufficient:

```shell
touch .ocamlformat
```

However, you can of course configure your formatter in more detail by
referring to its
[documentation](https://github.com/ocaml-ppx/ocamlformat?tab=readme-ov-file#usage).


#### Installing dependencies

Now that we have extensively described our project's development
dependencies, we can install all of them. First, run:


```shell
dune build
```

This will update the OPAM file (generated from our `dune-project`
file). Next, we can ask OPAM to install all our dependencies in our
current _switch_ (we reuse the `-y` flag to automatically confirm all
steps):


```shell
opam install . --deps-only --with-dev-setup -y
```

Normally, **everything should go smoothly**. If not, you can find support through the various [communication channels](https://ocaml.org/community) of the OCaml community, which is very friendly and responsive (and don’t hesitate to send us any missing information or requests for corrections/clarifications).  
From our point of view, this setup is generic enough to _bootstrap_ a
wide variety of OCaml projects.

At this point, we have _only_ set up an OCaml development environment,
but YOCaml has not been mentioned yet. Indeed, it is time to actually
start using YOCaml.

## A first use of YOCaml

Now that we have an environment (sandboxed or not, depending on your
preferences) suitable for writing OCaml, we can add YOCaml
dependencies. As with any time we want to add dependencies to the
project, we need to modify the `dune-project` file (the section
dedicated to describing the package):


```diff
  (package
   (name blog)
   (synopsis "My first blog using YOCaml")
   (description 
     "My first personal blog using YOCaml for 
     fun and profit")
   (depends
    (ocaml (>= 5.3.0))
+
+   (yocaml (>= 2.4.1))
+   (yocaml_unix (>= 2.4.1))
 
    ;; Dev setup
    (utop :with-dev-setup)
    (ocamlformat :with-dev-setup)
    (ocp-indent :with-dev-setup)
    (merlin :with-dev-setup)
    (ocaml-lsp-server :with-dev-setup)))
```

The tutorial assumes that we are using at least version `2.4.1` of
YOCaml, hence the version constraint, and since we assume the reader
is using a _UNIX-like_ distribution, we install `yocaml_unix`.

As with any modification to the `dune-project` file, we need to
regenerate the OPAM file(s) and then install our dependencies in the
current _switch_:


```shell
dune build
opam install . --deps-only --with-dev-setup -y
```

The difference between the **YOCaml** package and the **YOCaml_unix**
package will be explained in detail in the following sections, but we
can briefly summarize:

- `yocaml` describes the functional core of YOCaml and allows you to
  define programs.
- `yocaml_unix` is a runtime context; it takes a _YOCaml program_
  (defined using the `yocaml` package) and executes it.

In general, the concept of a _runtime_, here `yocaml_unix`, comes into
play at the very end of the project, once all tasks have been
defined. But don’t worry—all of these concepts will be fully detailed
in the next guide.

Now, we will _actually use YOCaml_ in a simple example: we will just
_log_ `"Hello World"` to the standard output.


### A first binary

As mentioned in the introduction, YOCaml is a collection of packages
that does not impose any particular ceremony. You can organize your
source code however you like. However, for the following guides, we
will assume that the sources of our program are located in the
`my-first-blog/bin` directory:


```shell
mkdir bin
touch bin/dune
touch bin/blog.ml
```

As we mentioned in the `dune-project` file to generate empty
interfaces for executables, it is not necessary to create a
`bin/blog.mli` file. We can now modify the `dune` file to describe our
_binary_:



```dune
(executable 
  (public_name blog)
  (libraries yocaml yocaml_unix))
```

Now, let's modify our `blog.ml` file to use YOCaml to print `Hello
World` to the standard output. The goal of this step is to ensure that
our environment is set up correctly; in this section, **it is not
necessary to understand what is happening in for the moment**:


<!-- $MDX skip -->
```ocaml
let program () = 
  Yocaml.Eff.log ~level:`Info "Hello World, from YOCaml"
  
let () = 
  Yocaml_unix.run ~level:`Debug program
```

Run the program using the following command:


```shell
dune exec bin/blog.exe
```


It should display `Hello World, from YOCaml` on the standard
output. At this point, **we have a functional working environment**
that can be easily modified to add new dependencies! One final step
(particularly optional) would be to add a license file at the root of
our project and a `README.md` file that explains, at minimum, how to
clone the project and initialize a local _switch_ using the following
command:



```shell
opam update
opam switch create . --deps-only --with-dev-setup -y
```

We can now move on to the next section to explore the fundamental
concepts of YOCaml and, finally, build our first blog!
